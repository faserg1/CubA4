OpCapability Shader
OpCapability Int64
OpMemoryModel Logical Simple
OpEntryPoint Vertex %main "main" %v_inPos %v_inUVW %v_instance_index %v_outPos %v_outUVW %v_outDebug1 %v_outDebug2 %v_outDebug3

; !!!!!!!!!!! debug namings
OpName %main "main"
OpName %v_matricies "v_matricies"
OpName %type_matrix_struct "MatrixStruct"
OpMemberName %type_matrix_struct 0 "view_global_pos"
OpMemberName %type_matrix_struct 1 "view"
OpMemberName %type_matrix_struct 2 "projection"

OpName %v_push "v_push"
OpName %v_chunk_range "v_chunk_range"

OpName %v_inPos "input_vertex"
OpName %v_inUVW "input_uvw"
OpName %v_outPos "output_vertex"
OpName %v_outUVW "output_uvw"
OpName %v_outDebug1 "v_outDebug1"
OpName %v_outDebug2 "v_outDebug2"
OpName %v_outDebug3 "v_outDebug3"

; !!!!!!!!!!! decorations

; input/output

OpDecorate %v_inPos Binding 0
OpDecorate %v_inPos Location 0
OpDecorate %v_inUVW Binding 0
OpDecorate %v_inUVW Location 1
OpDecorate %v_outPos BuiltIn Position
OpDecorate %v_outUVW Location 1
OpDecorate %v_outDebug1 Location 2
OpDecorate %v_outDebug2 Location 3
OpDecorate %v_outDebug3 Location 4

; built in

OpDecorate %v_instance_index BuiltIn InstanceIndex

; structure types

OpDecorate %type_matrix_struct Block
OpMemberDecorate %type_matrix_struct 0 Offset 0
OpMemberDecorate %type_matrix_struct 1 Offset 32 ;
OpMemberDecorate %type_matrix_struct 2 Offset 96 ; 64 + 32

OpMemberDecorate %type_matrix_struct 1 MatrixStride	16
OpMemberDecorate %type_matrix_struct 2 MatrixStride 16
OpMemberDecorate %type_matrix_struct 1 RowMajor
OpMemberDecorate %type_matrix_struct 2 RowMajor

OpDecorate %type_chunk_range_struct Block
OpMemberDecorate %type_chunk_range_struct 0 Offset 0

OpDecorate %type_push_struct Block
OpMemberDecorate %type_push_struct 0 Offset 0
OpMemberDecorate %type_push_struct 1 Offset 24

; uniform buffers

OpDecorate %v_matricies Binding 0 ; World Info
OpDecorate %v_matricies DescriptorSet 0

OpDecorate %v_chunk_range Binding 1 ; Chunk Info
OpDecorate %v_chunk_range DescriptorSet 1

; spec ids

OpDecorate %chunk_size_const SpecId 0

; !!!!!!!!!!! types

; basic types

%type_void = OpTypeVoid ; void
%type_bool = OpTypeBool ; void
%type_int_32 = OpTypeInt 32 1 ; int 32 signed
%type_uint_32 = OpTypeInt 32 0 ; int 32 unsigned
%type_float_32 = OpTypeFloat 32 ; float
%type_int_64 = OpTypeInt 64 1 ; int 64 signed

; vector types

%type_vec3_uint_32 = OpTypeVector %type_uint_32 3 ; int64 x3
%type_vec3_int_64 = OpTypeVector %type_int_64 3 ; int64 x3
%type_vec4_int_64 = OpTypeVector %type_int_64 4 ; int64 x4
%type_vec3_float_32 = OpTypeVector %type_float_32 3 ; float x3
%type_vec4_float_32 = OpTypeVector %type_float_32 4 ; float x4

; matrix types

%type_mat4x4_float_32 = OpTypeMatrix %type_vec4_float_32 4 ; float 4x4

; array types
%type_runtime_array_vec3_uint_32 = OpTypeRuntimeArray %type_vec3_uint_32

; struct types

%type_matrix_struct = OpTypeStruct %type_vec3_int_64 %type_mat4x4_float_32 %type_mat4x4_float_32 ; struct: view_global_pos view projection
%type_chunk_range_struct = OpTypeStruct %type_runtime_array_vec3_uint_32
%type_push_struct = OpTypeStruct %type_vec3_int_64 %type_int_32

; function types

%func_void = OpTypeFunction %type_void ; void ()
%func_vec3_float_32 = OpTypeFunction %type_vec3_float_32 ; vec3_float_32 ()
%func_vec3_uint_32 = OpTypeFunction %type_vec3_uint_32 %type_uint_32 ; vec3_uint_32 (uint_32)

; !!!!!!!!!!! pointers

; vectors 
%p_vec4_float_32_in = OpTypePointer Input %type_vec4_float_32 ; pointer to input float
%p_vec3_float_32_in = OpTypePointer Input %type_vec3_float_32 ; pointer to input float
%p_vec4_float_32_out = OpTypePointer Output %type_vec4_float_32 ; pointer to output float
%p_vec3_float_32_out = OpTypePointer Output %type_vec3_float_32 ; pointer to output float

; uniform
%p_matrix_struct_uniform = OpTypePointer UniformConstant %type_matrix_struct
%p_mat4x4_float_32_uniform = OpTypePointer UniformConstant %type_mat4x4_float_32
%p_vec3_int64_uniform = OpTypePointer UniformConstant %type_vec3_int_64

%p_chunk_range_struct_uniform = OpTypePointer UniformConstant %type_chunk_range_struct
%p_runtime_array_vec3_uint_32_uniform = OpTypePointer UniformConstant %type_runtime_array_vec3_uint_32
%p_vec3_uint_32_uniform = OpTypePointer UniformConstant %type_vec3_uint_32 ; pointer to uniform float

;push constants
%p_vec3_int64_push = OpTypePointer PushConstant %type_vec3_int_64
%p_int32_push = OpTypePointer PushConstant %type_int_32
%p_push_struct = OpTypePointer PushConstant %type_push_struct

; input

%p_uint_32_in = OpTypePointer Input %type_uint_32

; function

%p_uint_32_function = OpTypePointer Function %type_uint_32

; !!!!!!!!!!! constants

%const_uint32_0 = OpConstant %type_uint_32 0
%const_uint32_1 = OpConstant %type_uint_32 1
%const_uint32_2 = OpConstant %type_uint_32 2

; Placeholders

%const_zero_int64 = OpConstant %type_int_64 0
%const_zero_float32 = OpConstant %type_float_32 0
%const_one_float32 = OpConstant %type_float_32 1
%const_two_float32 = OpConstant %type_float_32 2
%const_minus_one_float32 = OpConstant %type_float_32 -1

; Размер одного элемента chunk range
%chunk_range_element_size = OpConstant %type_uint_32 12; uint_32 (32 / 8 = 4) * 3 = 12

; Единичный вектор
%const_vec3_uint32_1_1_1 = OpConstantComposite %type_vec3_uint_32 %const_uint32_1 %const_uint32_1 %const_uint32_1

; !!!!!!!!!!! Spec constants

%chunk_size_const = OpSpecConstant %type_int_32 1

; !!!!!!!!!!! vars

; vectors
%v_inPos = OpVariable %p_vec3_float_32_in Input ; input float
%v_inUVW = OpVariable %p_vec3_float_32_in Input ; input float
%v_outPos = OpVariable %p_vec4_float_32_out Output ; output float
%v_outUVW = OpVariable %p_vec3_float_32_out Output ; output float

%v_outDebug1 = OpVariable %p_vec4_float_32_out Output ; output float
%v_outDebug2 = OpVariable %p_vec4_float_32_out Output ; output float
%v_outDebug3 = OpVariable %p_vec4_float_32_out Output ; output float

; built in

%v_instance_index = OpVariable %p_uint_32_in Input

; matricies
%v_matricies = OpVariable %p_matrix_struct_uniform Uniform

; chunk range
%v_chunk_range = OpVariable %p_chunk_range_struct_uniform Uniform

; special

%v_push = OpVariable %p_push_struct PushConstant

; !!!!!!!!!!! function to load bound from chunk range by index

%load_chunk_bound = OpFunction %type_vec3_uint_32 None %func_vec3_uint_32
%lcb_index = OpFunctionParameter %type_uint_32
%lcb_begin = OpLabel

; get pointer to array
%lcb_chunk_ranges_array = OpAccessChain %p_runtime_array_vec3_uint_32_uniform %v_chunk_range %const_uint32_0
%lcb_bound = OpAccessChain %p_vec3_uint_32_uniform %lcb_chunk_ranges_array %lcb_index
%lcb_bound_loaded = OpLoad %type_vec3_uint_32 %lcb_bound

; %chunk_range_element_size

OpReturnValue %lcb_bound_loaded
OpFunctionEnd

; !!!!!!!!!!! function to find current position in chunk

%find_current_position = OpFunction %type_vec3_float_32 None %func_vec3_float_32
%fcp_begin = OpLabel
; !!!! function begin

; Переменные

%fcp_index = OpVariable %p_uint_32_function Function
%fcp_passed = OpVariable %p_uint_32_function Function

; Инициализация

OpStore %fcp_index %const_uint32_0
OpStore %fcp_passed %const_uint32_0

; load push contant
%fcp_chunk_ranges_count_pointer = OpAccessChain %p_int32_push %v_push %const_uint32_1
%fcp_loaded_chunk_ranges_count = OpLoad %type_int_32 %fcp_chunk_ranges_count_pointer

; load instance index
%fcp_loaded_instance_index = OpLoad %type_uint_32 %v_instance_index

OpBranch %fcp_loop

; !!!! > Заголовок цикла

%fcp_loop = OpLabel
OpLoopMerge %fcp_end %fcp_loop_start None
OpBranch %fcp_loop_start
%fcp_loop_start = OpLabel

; !!!! > Тело цикла здесь

; Составляем индексы для границ диапазона
%fcp_index_loaded = OpLoad %type_uint_32 %fcp_index
%fcp_index_inc = OpIAdd %type_uint_32 %fcp_index_loaded %const_uint32_1

; Загружаем границы
%fcp_bound1_loaded = OpFunctionCall %type_vec3_uint_32 %load_chunk_bound %fcp_index_loaded
%fcp_bound2_loaded = OpFunctionCall %type_vec3_uint_32 %load_chunk_bound %fcp_index_inc

; Составляем следующий индекс
%fcp_index_next = OpIAdd %type_uint_32 %fcp_index_loaded %const_uint32_2
OpStore %fcp_index %fcp_index_next

; диапазоны блоков задаются от и до включительно
; соответсвенно нужно прибавить единицу на каждую из сторон для конца
%fcp_bound2_extended = OpIAdd %type_vec3_uint_32 %fcp_bound2_loaded %const_vec3_uint32_1_1_1

; Вычитаем границы для получения длин диапазона
%fcp_i_total_range = OpISub %type_vec3_uint_32 %fcp_bound2_extended %fcp_bound1_loaded

; Выгрузка 
%fcp_i_total_range_x = OpCompositeExtract %type_uint_32 %fcp_i_total_range 0
%fcp_i_total_range_y = OpCompositeExtract %type_uint_32 %fcp_i_total_range 1
%fcp_i_total_range_z = OpCompositeExtract %type_uint_32 %fcp_i_total_range 2

; подсчет кол-ва блоков
%fcp_temp0 = OpIMul %type_uint_32 %fcp_i_total_range_x %fcp_i_total_range_y
%fcp_i_total_blocks_in_range = OpIMul %type_uint_32 %fcp_temp0 %fcp_i_total_range_z

; загрузка предыдущего значения
%fcp_passed_loaded = OpLoad %type_uint_32 %fcp_passed

; будущее и проверяемое значение
%fcp_passed_and_current = OpIAdd %type_uint_32 %fcp_passed_loaded %fcp_i_total_blocks_in_range

; сохранение пройденных блоков
OpStore %fcp_passed %fcp_passed_and_current

; !!!! > Конец тела цикла

; нужно ли продолжать цикл
%fcp_is_index_greater = OpUGreaterThanEqual %type_bool %fcp_loaded_instance_index %fcp_passed_and_current
OpBranchConditional %fcp_is_index_greater %fcp_loop %fcp_end
%fcp_end = OpLabel

; !! математика для подсчета текущей позиции блока

; подготовка
%z_divider = OpIMul %type_uint_32 %fcp_i_total_range_x %fcp_i_total_range_y
%fcp_dif_index_and_passed = OpISub %type_uint_32 %fcp_loaded_instance_index %fcp_passed_loaded

; поиск смещений
%fcp_z_shift = OpUDiv %type_uint_32 %fcp_dif_index_and_passed %z_divider ; Здесь нужна целая часть от деления
%fcp_temp1 = OpIMul %type_uint_32 %fcp_z_shift %z_divider
%fcp_temp2 = OpISub %type_uint_32 %fcp_dif_index_and_passed %fcp_temp1
%fcp_y_shift = OpUDiv %type_uint_32 %fcp_temp2 %fcp_i_total_range_x ; Здесь нужна целая часть от деления
%fcp_x_shift = OpUMod %type_uint_32 %fcp_dif_index_and_passed %fcp_i_total_range_x ; Здесь нужен остаток от деления

; сбор вектора из смещений
%fcp_bound1_float = OpConvertUToF %type_vec3_float_32 %fcp_bound1_loaded
%fcp_i_shift = OpCompositeConstruct %type_vec3_uint_32 %fcp_x_shift %fcp_y_shift %fcp_z_shift
%fcp_shift = OpConvertUToF %type_vec3_float_32 %fcp_i_shift
%fcp_result = OpFAdd %type_vec3_float_32 %fcp_bound1_float %fcp_shift

; !!!! function end

OpReturnValue %fcp_result
OpFunctionEnd

; !!!!!!!!!!! program

%main = OpFunction %type_void None %func_void ;main
%main_begin = OpLabel
; !!!! main function block going here

; load matricies

%global_view = OpAccessChain %p_vec3_int64_uniform %v_matricies %const_uint32_0
%view_matrix = OpAccessChain %p_mat4x4_float_32_uniform %v_matricies %const_uint32_1
%projection_matrix = OpAccessChain %p_mat4x4_float_32_uniform %v_matricies %const_uint32_2

%loaded_global_view = OpLoad %type_vec3_int_64 %global_view
%loaded_matrix_view = OpLoad %type_mat4x4_float_32 %view_matrix
%loaded_matrix_projection = OpLoad %type_mat4x4_float_32 %projection_matrix

; load vertex

%loaded_vertex = OpLoad %type_vec3_float_32 %v_inPos ; load vertex position
%loaded_instance_position = OpFunctionCall %type_vec3_float_32 %find_current_position 

; load push constant
%access_chunk_pos = OpAccessChain %p_vec3_int64_push %v_push %const_uint32_0
%loaded_chunk_pos = OpLoad %type_vec3_int_64 %access_chunk_pos

; math

; Вычисление разницы позицый между камерой и текущим чанком
%chunk_from_view_vec3 = OpISub %type_vec3_int_64 %loaded_chunk_pos %loaded_global_view
; Размер чанка в 64
%chunk_size_64 = OpSConvert %type_int_64 %chunk_size_const
; Делаем вектор из размера чанка
%chunk_size_vector = OpCompositeConstruct %type_vec3_int_64 %chunk_size_64 %chunk_size_64 %chunk_size_64
; Умножаем разницу позиций на размер чанка
%chunk_from_view_vec3_scaled = OpIMul %type_vec3_int_64 %chunk_from_view_vec3 %chunk_size_vector
; Конвертируем в float
%chunk_from_view_f = OpConvertSToF %type_vec3_float_32 %chunk_from_view_vec3_scaled
; Перемещаем вершину к инстансу
%moved_vertex = OpFAdd %type_vec3_float_32 %loaded_vertex %loaded_instance_position
; Перемещаем вершину к чанку
%moved_vertex_2 = OpFAdd %type_vec3_float_32 %moved_vertex %chunk_from_view_f

; пересобираем полученную разницу в vec4
%calculated_vertex = OpCompositeConstruct %type_vec4_float_32 %moved_vertex_2 %const_one_float32

OpStore %v_outDebug1 %calculated_vertex

; в Vulkan в окнном пространстве y смотрит вниз

%calculated_vertex_y = OpCompositeExtract %type_float_32 %calculated_vertex 1
%calculated_vertex_y_new = OpFDiv %type_float_32 %calculated_vertex_y %const_minus_one_float32
;%calculated_vertex_y_new = OpFDiv %type_float_32 %calculated_vertex_y %const_one_float32
%vulkan_inverted_y_vertex = OpCompositeInsert %type_vec4_float_32 %calculated_vertex_y_new %calculated_vertex 1

; делаем тоже самое для UVW

%uvw_coords = OpLoad %type_vec3_float_32 %v_inUVW
%coord_v = OpCompositeExtract %type_float_32 %uvw_coords 1
%v_inverted = OpFSub %type_float_32 %const_one_float32 %coord_v
%uvw_coords_v_inverted = OpCompositeInsert %type_vec3_float_32 %v_inverted %uvw_coords 1

; проецируем в окнное пространство

%viewed_vertex = OpVectorTimesMatrix %type_vec4_float_32 %vulkan_inverted_y_vertex %loaded_matrix_view

OpStore %v_outDebug2 %viewed_vertex

%projected_vertex = OpVectorTimesMatrix %type_vec4_float_32 %viewed_vertex %loaded_matrix_projection

OpStore %v_outDebug3 %projected_vertex

; нормализируем вершину

%projected_vertex_z = OpCompositeExtract %type_float_32 %projected_vertex 2
%projected_vertex_w = OpCompositeExtract %type_float_32 %projected_vertex 3
%temp_z = OpFAdd %type_float_32 %projected_vertex_z %projected_vertex_w
%projected_vertex_z_new = OpFDiv %type_float_32 %temp_z %const_two_float32
%total_vertex = OpCompositeInsert %type_vec4_float_32 %projected_vertex_z_new %projected_vertex 2

; сохраняем вершину

OpStore %v_outPos %total_vertex

; Отправляем координату UVW в следующий шейдер

OpStore %v_outUVW %uvw_coords_v_inverted

; !!!! main function block done here
OpReturn
OpFunctionEnd ;main
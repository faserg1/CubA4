OpCapability Shader
OpCapability Int64
OpMemoryModel Logical Simple
OpEntryPoint Vertex %main "main" %v_inPos %v_instance_index %v_outPos

; !!!!!!!!!!! debug namings
OpName %main "main"
OpName %v_matricies "v_matricies"
OpName %type_matrix_struct "MatrixStruct"
OpMemberName %type_matrix_struct 0 "view_global_pos"
OpMemberName %type_matrix_struct 1 "view"
OpMemberName %type_matrix_struct 2 "projection"

OpName %v_chunk_pos "v_chunk_pos"
OpName %v_chunk_ranges_count "v_chunk_ranges_count"
OpName %v_chunk_range "v_chunk_range"

OpName %v_inPos "input_vertex"
OpName %v_outPos "output_vertex"

; !!!!!!!!!!! decorations

; input/output

OpDecorate %v_inPos Binding 0
OpDecorate %v_inPos Location 0
OpDecorate %v_outPos BuiltIn Position

; built in

OpDecorate %v_instance_index BuiltIn InstanceIndex

; structure types

OpDecorate %type_matrix_struct Block
OpMemberDecorate %type_matrix_struct 0 Offset 0
OpMemberDecorate %type_matrix_struct 1 Offset 32 ;
OpMemberDecorate %type_matrix_struct 2 Offset 96 ; 64 + 32

OpMemberDecorate %type_matrix_struct 1 MatrixStride	16
OpMemberDecorate %type_matrix_struct 2 MatrixStride 16
OpMemberDecorate %type_matrix_struct 1 RowMajor
OpMemberDecorate %type_matrix_struct 2 RowMajor

OpDecorate %type_chunk_range_struct Block
OpMemberDecorate %type_chunk_range_struct 0 Offset 0

; uniform buffers

OpDecorate %v_matricies Binding 0 ; World Info
OpDecorate %v_matricies DescriptorSet 0

OpDecorate %v_chunk_range Binding 1 ; Chunk Info
OpDecorate %v_chunk_range DescriptorSet 1

; push constants

OpDecorate %v_chunk_pos Offset 0
OpDecorate %v_chunk_ranges_count Offset 24

; spec ids

OpDecorate %chunk_size_const SpecId 0

; !!!!!!!!!!! types

; basic types

%type_void = OpTypeVoid ; void
%type_bool = OpTypeBool ; void
%type_int_32 = OpTypeInt 32 1 ; int 32 signed
%type_uint_32 = OpTypeInt 32 0 ; int 32 unsigned
%type_float_32 = OpTypeFloat 32 ; float
%type_int_64 = OpTypeInt 64 1 ; int 64 signed

; vector types

%type_vec3_uint_32 = OpTypeVector %type_uint_32 3 ; int64 x3
%type_vec3_int_64 = OpTypeVector %type_int_64 3 ; int64 x3
%type_vec4_int_64 = OpTypeVector %type_int_64 4 ; int64 x4
%type_vec3_float_32 = OpTypeVector %type_float_32 3 ; float x3
%type_vec4_float_32 = OpTypeVector %type_float_32 4 ; float x4

; matrix types

%type_mat4x4_float_32 = OpTypeMatrix %type_vec4_float_32 4 ; float 4x4

; array types
%type_runtime_array_vec3_float_32 = OpTypeRuntimeArray %type_vec3_float_32

; struct types

%type_matrix_struct = OpTypeStruct %type_vec3_int_64 %type_mat4x4_float_32 %type_mat4x4_float_32 ; struct: view_global_pos view projection
%type_chunk_range_struct = OpTypeStruct %type_runtime_array_vec3_float_32

; function types

%func_void = OpTypeFunction %type_void ; void ()
%func_vec3_float_32 = OpTypeFunction %type_vec3_float_32 ; vec3_float_32 ()

; !!!!!!!!!!! pointers

; vectors 
%p_vec4_float_32_in = OpTypePointer Input %type_vec4_float_32 ; pointer to input float
%p_vec3_float_32_in = OpTypePointer Input %type_vec3_float_32 ; pointer to input float
%p_vec4_float_32_out = OpTypePointer Output %type_vec4_float_32 ; pointer to output float

; uniform
%p_matrix_struct_uniform = OpTypePointer Uniform %type_matrix_struct
%p_mat4x4_float_32_uniform = OpTypePointer Uniform %type_mat4x4_float_32
%p_vec3_int64_uniform = OpTypePointer Uniform %type_vec3_int_64

%p_chunk_range_struct_uniform = OpTypePointer Uniform %type_chunk_range_struct
%p_runtime_array_vec3_float_32_uniform = OpTypePointer Uniform %type_runtime_array_vec3_float_32
%p_vec3_float_32_uniform = OpTypePointer Uniform %type_vec3_float_32 ; pointer to uniform float

;push constants
%p_vec3_int64_push = OpTypePointer PushConstant %type_vec3_int_64
%p_int32_push = OpTypePointer PushConstant %type_int_32

; input

%p_uint_32_in = OpTypePointer Input %type_uint_32

; function

%p_uint_32_function = OpTypePointer Function %type_uint_32

; !!!!!!!!!!! constants

%const_uint32_0 = OpConstant %type_uint_32 0
%const_uint32_1 = OpConstant %type_uint_32 1
%const_uint32_2 = OpConstant %type_uint_32 2

; Placeholders

%const_zero_int64 = OpConstant %type_int_64 0
%const_zero_float32 = OpConstant %type_float_32 0
%const_one_float32 = OpConstant %type_float_32 1

; !!!!!!!!!!! Spec constants

%chunk_size_const = OpSpecConstant %type_int_32 1

; !!!!!!!!!!! vars

; vectors
%v_inPos = OpVariable %p_vec3_float_32_in Input ; input float
%v_outPos = OpVariable %p_vec4_float_32_out Output ; output float

; built in

%v_instance_index = OpVariable %p_uint_32_in Input

; matricies
%v_matricies = OpVariable %p_matrix_struct_uniform Uniform

; chunk range
%v_chunk_range = OpVariable %p_chunk_range_struct_uniform Uniform

; special

%v_chunk_pos = OpVariable %p_vec3_int64_push PushConstant
%v_chunk_ranges_count = OpVariable %p_int32_push PushConstant

; !!!!!!!!!!! function to find current position in chunk

%find_current_position = OpFunction %type_vec3_float_32 None %func_vec3_float_32
%fcp_begin = OpLabel
; !!!! function begin

; Переменные

%fcp_index = OpVariable %p_uint_32_function Function
%fcp_passed = OpVariable %p_uint_32_function Function

; Инициализация

OpStore %fcp_index %const_uint32_0
OpStore %fcp_passed %const_uint32_0

; load push contant
%fcp_loaded_chunk_ranges_count = OpLoad %type_int_32 %v_chunk_ranges_count

; load instance index
%fcp_loaded_instance_index = OpLoad %type_uint_32 %v_instance_index

; get pointer to array
%fcp_chunk_ranges_array = OpAccessChain %p_runtime_array_vec3_float_32_uniform %v_chunk_range %const_uint32_0

OpBranch %fcp_loop

; !!!! > Заголовок цикла

%fcp_loop = OpLabel
OpLoopMerge %fcp_end %fcp_loop_start None
OpBranch %fcp_loop_start
%fcp_loop_start = OpLabel

; !!!! > Тело цикла здесь

; Загружаем границы диапазона
%fcp_index_loaded = OpLoad %type_uint_32 %fcp_index
%fcp_bound1 = OpAccessChain %p_vec3_float_32_uniform %fcp_chunk_ranges_array %fcp_index_loaded
%fcp_index_inc = OpIAdd %type_uint_32 %fcp_index_loaded %const_uint32_1
%fcp_bound2 = OpAccessChain %p_vec3_float_32_uniform %fcp_chunk_ranges_array %fcp_index_inc

; Составляем следующий индекс
%fcp_index_next = OpIAdd %type_uint_32 %fcp_index_loaded %const_uint32_2
OpStore %fcp_index %fcp_index_next

; Загружаем границы
%fcp_bound1_loaded = OpLoad %type_vec3_float_32 %fcp_bound1
%fcp_bound2_loaded = OpLoad %type_vec3_float_32 %fcp_bound2

; Вычитаем границы для получения длин диапазона
%fcp_total_range = OpFSub %type_vec3_float_32 %fcp_bound2_loaded %fcp_bound1_loaded

; конвертация
%fcp_i_total_range = OpConvertFToU %type_vec3_uint_32 %fcp_total_range

; Выгрузка 
%fcp_i_total_range_x = OpCompositeExtract %type_uint_32 %fcp_i_total_range 0
%fcp_i_total_range_y = OpCompositeExtract %type_uint_32 %fcp_i_total_range 1
%fcp_i_total_range_z = OpCompositeExtract %type_uint_32 %fcp_i_total_range 2

; подсчет кол-ва блоков
%fcp_temp0 = OpIMul %type_uint_32 %fcp_i_total_range_x %fcp_i_total_range_y
%fcp_i_total_blocks_in_range = OpIMul %type_uint_32 %fcp_temp0 %fcp_i_total_range_z

; загрузка предыдущего значения
%fcp_passed_loaded = OpLoad %type_uint_32 %fcp_passed

; будущее и проверяемое значение
%fcp_passed_and_current = OpIAdd %type_uint_32 %fcp_passed_loaded %fcp_i_total_blocks_in_range

; сохранение пройденных блоков
OpStore %fcp_passed %fcp_passed_and_current

; !!!! > Конец тела цикла

; нужно ли продолжать цикл
%fcp_is_index_greater = OpUGreaterThanEqual %type_bool %fcp_loaded_instance_index %fcp_passed_and_current
OpBranchConditional %fcp_is_index_greater %fcp_loop %fcp_end
%fcp_end = OpLabel

; !! математика для подсчета текущей позиции блока

; подготовка
%z_divider = OpIMul %type_uint_32 %fcp_i_total_range_x %fcp_i_total_range_y
%fcp_dif_index_and_passed = OpISub %type_uint_32 %fcp_loaded_instance_index %fcp_passed_loaded

; поиск смещений
%fcp_z_shift = OpUDiv %type_uint_32 %fcp_dif_index_and_passed %z_divider ; Здесь нужна целая часть от деления
%fcp_temp1 = OpIMul %type_uint_32 %fcp_z_shift %z_divider
%fcp_temp2 = OpISub %type_uint_32 %fcp_dif_index_and_passed %fcp_temp1
%fcp_y_shift = OpUDiv %type_uint_32 %fcp_temp2 %fcp_i_total_range_x ; Здесь нужна целая часть от деления
%fcp_x_shift = OpUMod %type_uint_32 %fcp_dif_index_and_passed %fcp_i_total_range_x ; Здесь нужен остаток от деления

; сбор вектора из смещений
%fcp_i_shift = OpCompositeConstruct %type_vec3_uint_32 %fcp_x_shift %fcp_y_shift %fcp_z_shift
%fcp_shift = OpConvertUToF %type_vec3_float_32 %fcp_i_shift
%fcp_result = OpFAdd %type_vec3_float_32 %fcp_bound1_loaded %fcp_shift

; !!!! function end

OpReturnValue %fcp_result
OpFunctionEnd

; !!!!!!!!!!! program

%main = OpFunction %type_void None %func_void ;main
%main_begin = OpLabel
; !!!! main function block going here

; load matricies

%global_view = OpAccessChain %p_vec3_int64_uniform %v_matricies %const_uint32_0
%view_matrix = OpAccessChain %p_mat4x4_float_32_uniform %v_matricies %const_uint32_1
%projection_matrix = OpAccessChain %p_mat4x4_float_32_uniform %v_matricies %const_uint32_2

%loaded_global_view = OpLoad %type_vec3_int_64 %global_view
%loaded_matrix_view = OpLoad %type_mat4x4_float_32 %view_matrix
%loaded_matrix_projection = OpLoad %type_mat4x4_float_32 %projection_matrix

; load vertex

%loaded_vertex = OpLoad %type_vec3_float_32 %v_inPos ; load vertex position
%loaded_instance_position = OpFunctionCall %type_vec3_float_32 %find_current_position 

; load push constant

%loaded_chunk_pos = OpLoad %type_vec3_int_64 %v_chunk_pos

; math

; Вычисление разницы позицый между камерой и текущим чанком
%chunk_from_view_vec3 = OpISub %type_vec3_int_64 %loaded_chunk_pos %loaded_global_view
; Размер чанка в 64
%chunk_size_64 = OpSConvert %type_int_64 %chunk_size_const
; Делаем вектор из размера чанка
%chunk_size_vector = OpCompositeConstruct %type_vec3_int_64 %chunk_size_64 %chunk_size_64 %chunk_size_64
; Умножаем разницу позиций на размер чанка
%chunk_from_view_vec3_scaled = OpIMul %type_vec3_int_64 %chunk_from_view_vec3 %chunk_size_vector
; Конвертируем в float
%chunk_from_view_f = OpConvertSToF %type_vec3_float_32 %chunk_from_view_vec3_scaled
; Перемещаем вершину к инстансу
%moved_vertex = OpFAdd %type_vec3_float_32 %loaded_vertex %loaded_instance_position
; Перемещаем вершину к чанку
%moved_vertex_2 = OpFAdd %type_vec3_float_32 %moved_vertex %chunk_from_view_f

; пересобираем полученную разницу в vec4
%calculated_vertex = OpCompositeConstruct %type_vec4_float_32 %moved_vertex_2 %const_one_float32

%viewed_vertex = OpVectorTimesMatrix %type_vec4_float_32 %calculated_vertex %loaded_matrix_view
%projected_vertex = OpVectorTimesMatrix %type_vec4_float_32 %viewed_vertex %loaded_matrix_projection

OpStore %v_outPos %projected_vertex

; !!!! main function block done here
OpReturn
OpFunctionEnd ;main